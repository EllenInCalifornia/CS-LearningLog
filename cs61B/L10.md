# Review: Typing Rules
* Compiler allows the memory box to hold any subtype.
* Compiler allows calls based on static type.
* Overriden non-static methods are selected at runtime based on dynamic type.
* For overloaded methods, the method is selected at compile time.

## exercise 
* casting, 注意外面可以有括号  
```java
Object o2 = new ShowDog("dd",12);
ShowDog sdx = ((ShowDog)o2);
```
# Subtype Polymorphism
* Polymorphism: “providing a single interface to entities of different types”
* Problem：  in python, there is operator overloding, how to do this in Java?

## Problematic code 
```java
public class Dog {
    private String name;
    private int size;
    public Dog(String n, int s) {
        name = n;
        size = s;
    }

    public void bark() {
        System.out.println(name + "says: bark");
    }
}
```
```java
public class Maximizer {
    public static Object max(Object[] items) {
        int maxDex = 0;
        for (int i = 0; i < items.length; i++) {
            if (items[maxDex] < items[i]) {
            //problematic 
                maxDex = i;
            }
        }
        return items[maxDex];
    }

    public static void main(String[] args) {
        Dog[] dogs = {new Dog("dd",10), new Dog("ss",15), new Dog("jj",30)};
        Dog maxDog = (Dog) max(dogs);
        maxDog.bark();
    }
}
``` 
* the above code is problematic 

## fix the above code with interface 
* 1) 创建一个interafce OurComparable 
```java 
public interface OurComparable {
    /*returns -1 if this < 0; 0 equal; 1 >;
     */
    public int compareTo(Object o); // Object
}
```
* 2) dogs implements OurComparable, 注意method里的cast type， 把generic type 转成dog 
```java
public class Dog implements OurComparable{
    private String name;
    private int size;
    public Dog(String n, int s) {
        name = n;
        size = s;
    }

    public int compareTo(Object o) {
        //casting the type
        Dog tempDog = (Dog) o;
        if (this.size > tempDog.size) {
            return 1;
        } else if (this.size == tempDog.size) {
            return 0;
        }
        return -1;
    }

    public void bark() {
        System.out.println(name + "says: bark");
    }
}
```
* 3）修改maximizer， main不用修改；<br> OurComparable 代表一个generic class，代表一种 object data type;<br>OurComparable 的一个subclass 是dog 

```java
public class Maximizer {
    public static OurComparable max(OurComparable[] items) {
        int maxDex = 0;
        for (int i = 0; i < items.length; i++) {
            if (items[maxDex].compareTo(items[i]) == -1) {
                maxDex = i;
            }
        }
        return items[maxDex];
    }

    public static void main(String[] args) {
        Dog[] dogs = {new Dog("dd",10), new Dog("ss",15), new Dog("jj",30)};
        Dog maxDog = (Dog) max(dogs);
        maxDog.bark();
    }
}
``` 
now this code works fine. 

## better the above code 
* OurComparable
```java
public interface OurComparable {
    /*returns negative if this < 0; 0 equal; positive >;
     */
    public int compareTo(Object o); // Object
    //等价于== compareTo（OurComparable o）
}
```
* dog code 
```java 
... 
public int compareTo(Object o) {
        //casting the type
        Dog tempDog = (Dog) o;
        return this.size - tempDog.size;
    }
```
* Maximizer

```java 
public static OurComparable max(OurComparable[] items) {
        int maxDex = 0;
        for (int i = 0; i < items.length; i++) {
            if (items[maxDex].compareTo(items[i]) < 0) {
                maxDex = i;
            }
        }
        return items[maxDex];
    }
```

# The Issues With OurComparable
* Awkward casting to/from Objects.
* we made it up 

# built- in interface comparable 
* this interface is already defined and used by tons of libraries. 
* It uses generics.
'''java 
public interface Comparable<T> {
     public int compareTo(T obj);
} 
```

```java
    public class Dog implements Comparable<Dog> {
    private String name;
    private int size;
    public Dog(String n, int s) {
        name = n;
        size = s;
    }

    public int compareTo(Dog adog) {
        return this.size - adog.size;
    }

    public void bark() {
        System.out.println(name + " says: bark");
    }

}
```
    

